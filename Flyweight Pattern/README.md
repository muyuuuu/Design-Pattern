# 享元模式

背景起因：如果开发网站，一个用户一个需求，但大体功能类似。如果每次有需求，都复制粘贴代码、申请服务器，维护会很累。比如三个产品展示的网站、三个博客的网站，就需要六个网站的实例。而本质的代码是一样的。如果网站增多，实例增多，服务器资源浪费严重。初版代码：

```cpp
class web {
public:
    use(info){
        show(info)
    }
}

main() {
    c1 = web{"产品展示"};
    c2 = web{"产品展示"};
    c3 = web{"产品展示"};
    c4 = web{"博客"};
    c5 = web{"博客"};
    c6 = web{"博客"};
    c1.use();
    c2.use();
    c3.use();
    c4.use();
    c5.use();
    c6.use();
}
```

所以网站可以共享一套代码，虽然不同网站数据不同，但可以根据用户 ID 区分用户，具体数据和模板可以不同，核心代码和数据库共享。硬盘、内存、CPU、数据库等达成共享，减少服务器资源，代码也只用维护一份实例。

---

享元模式：运用共享技术，有效的支持大量细粒度的对象。创建一个享元工厂，创建并管理对象。用户请求时，已经创建，则返回已创建的实例；否则创建实例。此外也需要考虑不需要共享的对象。

代码见 `version1` 文件夹下。

- `web.h`，网站的虚基类
- `concreteweb.h`，实现具体的网站
- `webfactory.h`，工厂，用于创建对象，也就是具体的网站
- `main.cpp`，编译运行

享元避免了大量非常类似的开销。程序设计中，需要大量生成细粒度的类实例来表示数据。这些实例除了几个参数外基本相同，可以大幅度减少所需实例化类的数量。如果将参数移动到类的外面，就像 `version1` 的代码一样，调用方法时传入，可以大幅减少实例的数量。

不管建几个网站，只要是卖东西，内容是一样的；只要是博客，内容也是一样的。但只体现了共享，没有体现对象间的不同。

- 内部状态，享元对象内部的共享部分
- 外部状态，不可以共享的状态

对于客户帐号，就是外部状态，由专门对象处理。

---

所以第二版代码增加 `user` 类，协调外部状态，代码位于 `version2` 文件夹。只要需求类似，实际开发的代码也就几种。对服务器而言，实例少，开销也少。

# 应用场景

- 程序使用了大量的对象，而这些对象造成了大量的开销，可以考虑使用
- 删除对象的外部状态，可以用相对较少的内部状态取代很多组对象，可以考虑使用。比如五子棋游戏场景。

运用共享技术有效的支持大量细粒度的对象，不影响客户的使用。但本身带来逻辑难以设计的问题，如状态到底是外部还是内部。