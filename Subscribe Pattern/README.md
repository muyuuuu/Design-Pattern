# 观察者模式

以最为喜闻乐见的高中生活为例：几个同学说，老师来了把我叫醒；老师来了告诉我们一下，我们就不玩了。初版代码：

```cpp
// 放风人的类
class observer{
    vector<stu> v;
    void append(stu1){
        v.push_back(stu1);
    }
    void notify(){
        for i in v
            i.update();
    }
}
// 玩耍同学的类，或者说，观察者类
class stu{
    void update(){
        cout << "老师来了";
    }
}
// 客户端程序
int main(){
    o = observer();
    s1 = stu();
    s2 = stu();
    s3 = stu();

    o.append(s1);
    o.append(s2);
    o.append(s3);

    o.notify();
}
```

但是相互耦合，放风者类需要读取观察者信息，观察者需要放风者的状态。程序应该依赖抽象，而不是相互依赖。

## 解耦

放风人也应该是一个具体的类，如果放风人有事，消息的发送者就会是老师，由老师来告诉他们不要玩了。

- `notifierbase.h`，基类，用于通风报信
- `observerbase.h`，观察者基类
- `boss.h`，继承 notifierbase.h，用于发送消息
- `secret.h`，继承 notifierbase.h，用于发送消息
- `stu1.h`，继承 observerbase.h，可以有自己的动作
- `stu2.h`，继承 observerbase.h，可以有自己的动作
- `main.cpp`，g++ 编译运行

观察者模式定义了一种一对多的依赖关系，多个观察者同时监听某一个对象。对象发声变化时，通知所有观察者，让它们自动更新自己。

一个抽象通知者，把所有观察者聚集到一起。每个通知者可以有任意数量的观察者，也可以取消某个观察者。通过通知者的接口，实现观察者的增加、删除和更新。所以，观察者类一般含有通知者要求的更新方法。需要具体场景时，实例化观者者的抽象类即可。

与此同时，可以设置通知者的状态，可以由观察者获取状态，实现更加多样化的功能。

## 特点与不足

## 特点

1. 将一个系统分割成一系列相互协作的类可能有副作用，需要维护相关对象间的一致性。而不希望为了维护一致性，使类紧密耦合，维护、扩展和重用都不方便。而观察者模式可以很好的做到这一点，发生改变时，通知所有观察者更新即可。
2. 所以，使用场景为：一个对象状态改变的同时，其它对象需要改变；尤其是不知道有多少对象需要改变。
3. 一个抽象模型有两个方面，一方面依赖另一方面，观察者模式可以将这两者封装在独立的对象中，各自独立的改变和复用。
4. 解除耦合，耦合的双方都依赖抽象，而不是依赖具体。各自的变化不会影响另一边。

## 不足之处

通知者发送消息时，不同的观察者可能会有不同的动作，比如 A 要隐藏，B 要打开，C 要关闭，不是同名的方法，之前的代码就失效了。

# 委托

- 对于通知者，发送消息时仍然调用更新方法
- 对于观察者，实现各自的不同名方法即可
- 将观察者各自的动作挂钩到通知者的更新函数上，也就是不同的动作委托给观察者的更新

一旦为委托分配了方法，委托将与该方法有完全相同的行为，委托的实例代表一个具体的函数。一个委托可以搭载多个方法，所有方法被依次唤起。使得委托对象所搭载的方法不需要属于同一个类。

也就是，不需要通知者类添加、删除和循环通知观察者了，转到委托搭载多个方法，解决了通知者与观察者耦合的问题。但委托对象所搭载的所有方法必须具有相同的参数列表和返回值类型。

---

假设 A 买了新手机换了手机号（事件），需要 B （通知者）把 C,D,...,Z （观察者）等人的电话发给 A。
1. B 发送很多人的号码给 A 会很累。
2. 观察者模式：B 把 A 的新号码发给 C,D,...,Z 即可，每个人有自己的非同名函数即处理方式，或忽略或添加。