以商场购买产品为例。商品可能频繁打折或回归原价，不可能每次打折都重新编译代码。如果在增加满300返80，满400返100等促销手段，工厂模式不能满足此类需求经常变动的场景，工厂的编译次数会很多，因为子类增加不完。

面向对象中，不是类越多越好，而是把属性和功能相同的对象抽象成一个类，这里需要抽象为两个类。第一个类用于打折，第二个类用于满 x 返 y，传参即可。

策略模式：将算法封装，可以相互替换。算法的变换不会影响客户，也就是，封装变化点。针对具体的策略编写代码，使用一个类去维护策略。

防止客户端判断使用哪一个算法，客户端判断策略时使用工厂模式。

- `strategy.h` 策略的虚基类
- `cashback.h` 返现策略的类
- `discounts.h` 打折策略的类
- `cashcontext.h` 策略管理类，根据不同的策略，返回结果。也可以方便的添加其他功能。如享受优惠策略的人数统计等。
- `factory.h` 工厂模式的类，实例化不同策略的类，传到策略上下文中
- `g++ main.cpp` 编译运行

# 总结

1. 不同策略的算法完成相同工作，只是实现不同。但可以用相同的方法调用算法，减少各类算法与使用算法的耦合。
2. strategy定义虚基类，子类实现，而 context 可以定义方法来执行子类继承虚基类的函数。提取公共功能。
3. 简化单元测试，分别通过每个算法单独的接口来测试。
4. 策略模式封装了变化，在这个例子中，再有其他捆绑销售、会员等销售策略，同样只增加策略类即可。