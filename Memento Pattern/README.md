# 备忘录模式

以打游戏为例，可以备份，某一关打不好就重新打这里。第一版代码：

```cpp
// 玩家初始化
player.getInit();
player.play();

// 保存进度
// 这里暴露了实现细节，不可取，客户端压力太大
// 如增加生命值、魔法值，都需要大幅改动
backup.attack = player.attack;
backup.defense = player.defense;

// 第一关没玩好，恢复
player.attack = backup.attack;
player.defense = backup.defense;
```

---

在不破坏封装性的前提下，捕获对象内部的状态，对象之外保存这个状态。这样就可以恢复到该对象之前保存的状态。

- 发起人，originator，创建一个备忘录，记录此时内部的状态，并可以使用备忘录恢复内部状态。可根据需要决定备忘录存储 originator 的哪些内部状态。就是上述例子中的打游戏的人，但**不应该直接开放全部的 public 接口**。
- 管理者，caretaker，负责保存好备忘录，不能对备忘录的内容进行操作和检查
- 备忘录，负责存储 originator 对象内部的状态，防止 originator 以外的其它对象访问备忘录。有两个接口，管理者 caretaker 只能看到窄接口，将备忘录传递给其它对象；originator 看到宽接口，允许访问先前状态所需的数据。应该是独立的类，**因为可能不用保存全部信息，只备份一些数据**。

---

- `caretaker.h`，负责保存和读取备忘录，不能对备忘录修改。也就是管理者和备忘录之间的桥梁。
- `originator.h`，游戏玩家，可以保存当前状态到备忘录，或从备忘录恢复状态
- `memo.h`，被 originator.h 支配，被创建与被读取。要保存的细节封装到 memo 中，更改保存的细节不会影响客户端。

需要注意的是，如果保存全部状态到备忘录对象中，资源消耗会很大。其它使用场景：

1. 适用于功能比较复杂，但需要维护和记录属性历史的类，或者需要保存的属性是众多属性中的一部分，管理者可以根据保存的 memo 恢复到之前的一个状态。
2. 比如存储可撤销操作的状态。
3. 对象的内部信息（游戏玩家）保存在对象以外的地方（备忘录），但必须由对象自己读取，备忘录可以把复杂的对象内部信息屏蔽，保证封装的边界。
4. 角色状态改变时，状态可能无效，使用备忘录恢复。