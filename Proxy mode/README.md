# 代理模式

一个场景，A追求B。第一版代码：

```cpp
class girl{
    string name;
    getName{return name}
};
```

```cpp
class pursuit{
    setGirl(girl a);
    void giveFlowers();
    void giveMoney();
    void giveChocolate();
};
```

```cpp
g = girl();
p = pursuit.setGirl(g);
p.giveMoney();
p.giveFlowers();
```

如果 A 不认识 B，那么就通过中间代理人。也就是，A 通过代理 P，送给 B 礼物。B 不认识 A，但能通过 P 获得礼物。

---

- `proxyBase.h`基类，代理要实现的接口
- `pursuit.h`，追求者类，继承 proxyBase，实现发送礼物的方法
- `proxy.h`，一个代理，继承 proxyBase，里面创建新的 A，也就是 B 不知道受到了谁的礼物。指定收到礼物的一方，调用 pursuit 的方法
- `girl.h`，被追求者类
- `main.cpp`，`g++` 编译并运行

代理模式，为其它对象（pursuit）提供一种代理（proxy），控制对这个对象（girl）的访问。因为 pursuit 和 proxy 继承同一个父类，有相同的接口，在任何使用实际类的场景，都可以使用代理。实际类中有真实的请求。

所谓代理，即对目标对象访问的一个中间层。它代表一个真实的对象，并呈现给外界一个假象，它就是真正的对象，但其实他的一切动作都是调用真实对象来完成的。

实际应用：
- 远程代理，为一个对象在不同的地址空间提供局部代表，隐藏一个对象在不同地址空间的事实。有两个类ClassA和ClassB，它们分别位于不同的机器上。如果ClassA想要调用ClassB中的方法，这时就需要一个远程代理。远程代理就好像是『远程对象的本地代表』，它是一个可以由本地方法调用的对象，其行为会转发到远程对象中。
- 虚拟代理，虚拟代理作为创建开销大的对象的代表，经常在我们真正需要一个对象时才创建这个开销大的真实对象。假设现在我们需要在一个应用程序上加载某个图像，因为加载图像是一个开销较大的工作，所以我们可以利用虚拟代理在图像加载未完成时显示一些信息，如：“图像加载中”，然后用户真的需要显示图像，将显示责任委托给创建出来的图像对象。
- 安全代理，用来控制真实对象访问时的权限，鉴权，限制了一些操作，屏蔽对真实角色的直接访问。
- 智能指引，调用真实的对象时，代理处理另外的事情。例如计算一个对象被引用的次数。

访问对象时引入一定的间接性，间接性可以附加很多用途。其实还有很多代理模式，以上代理我也只能理解远程代理、虚拟代理和保护代理，等哪天代码真的遇到了，再回过头来看理论。