# 装饰模式

## 引言

假设此时在写类似 QQ 形象的代码。

第一版代码：

```Cpp
class Person{
public:
    void wearT恤();
    void wear长裤();
    void wear短裤();
    void wear长袖();
    void show();
};

p = Person();
p.wratT恤();
p.show();
```

但违背了开放封闭原则，很容易的想法是：构造服饰的虚基类，而后构造各个服饰的子类。第二版代码的客户端：

```Cpp
a = new T恤();
b = new 长裤();
p = Person();
a.show();
b.show();
p.show();
```

其它装扮，在增加子类就可以了。上述代码的问题是：人先不穿衣服，在穿T恤，在穿裤子。应该在内部组装完毕，然后显示出来。非建造者模式，建造者模式要求建造的过程是稳定的，但此时的需求不是稳定的。穿衣的次序有很多种排列。但把所有的功能按顺序串联起来很难控制，如内裤穿里面是正常人，穿外面是超人，或造成不同的形象和不同的结果，所以不同的功能一定要按正确顺序连接起来。

---

给对象添加一些额外的职责，比生成子类更加灵活。

- `component`，基类，定义接口，子类去添加各种职责
- `compoPerson`，继承 component，人，具体被装饰的对象，一些其他操作
- `compoHouse`，继承 component，房子，具体被装饰的对象，一些其他操作
- `decorator`，所有装饰类的基类，继承 component，用于确定被装饰的对象，是 compoPerson 还是 compoHouse，执行相关动作
- `decorator1`，具体装饰物
- `decorator2`，具体装饰物
- `main.cpp`，g++ 编译运行

每个装饰对象的实现和如何使用装饰对象分离开，只关注自己要装饰的功能，不需要关系如何被添加到对象链中。

---

1. 为已有功能动态添加更多功能
2. 当系统需要新的功能，是向旧类添加新代码（增加了代码复杂度），还是实现装饰器来修饰（满足特定情况下会触发的特殊需求）。
3. 装饰模式，每个要装饰的功能放到单独的类中，让这个类包装要修饰的对象。可以在运行时有选择的根据需要，用包装对象装饰类。
4. 好处是：将类的核心功能和装饰功能区分开
5. 但装饰顺序很重要
6. 即使有了装饰功能，但类的核心功能却是最重要的，不要舍本逐末