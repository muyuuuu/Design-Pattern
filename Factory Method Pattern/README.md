# 工厂方法模式

简单工厂模式，工厂类包括了必要的逻辑判断，根据客户的请求动态实例化指定的类。对于客户端而言，去除了与产品的依赖。如果出现新的请求，就需要修改原有的类，违背了开放封闭原则。

工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂类与分支耦合，依据依赖倒转原则，把工厂类抽象出一个接口，接口只有一个方法，用于创建抽象产品的工厂方法，变成一个工厂抽象接口和多个具体生成对象的工厂。遇到需求，扩展运算类和增加相应的工厂类就可以了。工厂、其它产品没有发生变化，只是扩展的变化。

工厂方法实现时，客户端需要决定实例化哪一个工厂来运算，选择判断的问题仍然存在。

---

- `base.h`，基类，如运算类等
- `factory.h`，工厂类，虚基类，有一个用于创建抽象产品的工厂方法
- `simpleFactory.h`，简单工厂方法，含逻辑判断，本例不适用
- `undergraduate.h`，继承 `base`
- `undergraduateFac.h`，继承 `factory`，返回创建的 `undergraduate` 对象
- `volunteer.h`，继承 `base`
- `volunteerFac.h`，继承 `factory`，返回创建的 `volunteer` 对象
- `main.cpp`，编译运行

```cpp
// 创建志愿者，修改此处
IFactory* fac = new underGraduateFactory();
Base* s = fac->create();
```

工厂方法客服了开放-封闭的缺点，保持了封装对象创建过程的优点。更换对象时，不需要做大的改动，降低了客户程序与产品对象的耦合。每增加一个产品，就需要增加一个产品工厂类，增加额外开放量。

利用反射，可以解决分支判断的问题，可惜我还每学到那里。