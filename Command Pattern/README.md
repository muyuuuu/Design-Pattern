# 命令模式

以饭店吃饭为例。买饭的人和做饭的厨师接触过多，会导致：厨师忘记谁付了钱谁没有，谁要辣椒谁要多少；买饭的人会看着厨师，挑剔也就接踵而至。也就是，行为请求者和行为实现者的紧耦合。

对于买饭人的各类请求，可以对请求做日志；回退请求，就是撤销日志中的某部分。对于创建、记录、修改、撤销等行为操作，行为请求者和行为实现者的紧耦合不太合适。

请求者（买饭的人）不用知道是谁（哪位厨师）实现的，由日志（服务员）去记录并通知厨师去做。厨师可按照订单的顺序和要求制作，也不会出错，收钱也不会出错。

即使买饭的人说少要一份，服务员也会在订单上划一下，通知厨师即可。

## 紧耦合代码

```cpp
barbecuer {
public:
    烤羊肉();
    烤鸡翅();
};
main (){
    b = barbecuer();
    b.烤羊肉(10)；
    b.烤鸡翅(2);
}
```

这是路边摊模式，用户多了，请求多了，容易混乱。比如说，羊肉多了，少要一半，可程序已经执行了。烤肉的内部实现等行为，是自己的方法，具体如何做由内部命令实现，不该由客户端管理。应该增加服务员类，发送命令。

将烤肉者类中的多个方法，分别写成多个命令，被服务员请求。许多命令继承自抽象类，服务员对抽象类发送指令，具体执行哪一个命令，由用户决定。

## 松耦合代码

代码位于 `version1` 文件夹：
- `barbecuer.h`，厨师，用于执行具体的指令
- `command.h`，客户命令的虚基类
- `concretecmd.h`，继承 command.h，调用厨师类，执行具体的命令
- `waiter.h`，设置要被执行的命令，并使用运行时多台，告知具体的类去执行
- `main.cpp`，编译执行

但仍然存在的缺陷：
1. 并不是用户点一个菜，服务员就发送一次指令，而是点好之后一起发送
2. 鸡翅没了，服务员或厨师应该立刻反馈给用户，而不是客户去判断有没有
3. 客户的订单，要记录，方便收费和统计
4. 客户可能会因为点的太多了，而取消一些订单