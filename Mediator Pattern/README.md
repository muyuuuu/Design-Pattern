# 中介者模式

尽管将一个系统分割成许多对象可以增加复用性，但对象的相互连接的激增，会导致复用性降低。

大量的连接使得一个对象不可能在没有其它对象的支持下工作，系统表现为一个不可分割的整体，对系统行为进行改进就十分困难。违反了迪米特原则，应该通过中介者对象。

使用一个中介对象封装一系列的对象交互，对象之间不用直接通信、显式的相互引用，使耦合松散，可以独立改变他们之间的交互。

---

- `colleague.h`，抽象的同事类
- `concreteColleague.h`，具体同事类，实现具体的发送消息（调用中介者）与接收通知
- `mediator.h`，中介者类
- `concreteMediator.h`，具体中介者，需要掌握所有人员信息
- `main.cpp`，编译运行

---

但 `concreteMediator` 的职责太多了，如果出了问题，整个系统都会有问题。中介者模式很容易在系统中应用，也容易在系统中误用。出现了多对多的复杂交互群体，不要急于使用中介者模式，需要考虑这是否合理。

- 减少了各个模块的耦合，独立的修改和复用 `colleague`。
- 把对象的协作进行了抽象，中介作为独立的概念封装到对象中，将关注对象本身到关注对象之间的交互，宏观的看待系统。
- 但由于 concretemediator 会因为 concretecolleague 越来越多，变得十分复杂而不易维护。交互的复杂性变成了中介者的复杂性，这是优点也是缺点。

一般应用于一组定义良好的对象，但是通信方式较为复杂的场合，如 `GUI` 控件的通信。定制一个分布在多个类中的行为（中介者通信），但又不想生成太多子类（通信过于复杂）。